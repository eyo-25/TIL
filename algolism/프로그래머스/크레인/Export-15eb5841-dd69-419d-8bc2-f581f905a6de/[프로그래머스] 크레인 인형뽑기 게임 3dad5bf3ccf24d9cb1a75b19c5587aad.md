# [프로그래머스] 크레인 인형뽑기 게임

> [https://school.programmers.co.kr/learn/courses/30/lessons/64061](https://school.programmers.co.kr/learn/courses/30/lessons/64061)
> 

![crane_game_102.png](%5B%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%A5%E1%84%89%E1%85%B3%5D%20%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A6%E1%84%8B%E1%85%B5%E1%86%AB%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%92%E1%85%A7%E1%86%BC%E1%84%88%E1%85%A9%E1%86%B8%E1%84%80%E1%85%B5%20%E1%84%80%E1%85%A6%E1%84%8B%E1%85%B5%E1%86%B7%203dad5bf3ccf24d9cb1a75b19c5587aad/crane_game_102.png)

# **😀** 내 제출안

```jsx
function solution(board, moves) {
  var answer = 0;
  const bucket = [];

  for (let move = 0; move < moves.length; move++) {
    const col = moves[move] - 1;
    for (let row = 0; row < board.length; row++) {
      const pick = board[row][col];
      if (pick !== 0) {
        board[row][col] = 0;
        if (bucket[bucket.length - 1] === pick) {
          bucket.pop();
          answer += 2;
        } else {
          bucket.push(pick);
        }
        break;
      }
    }
  }

  return answer;
}
```

# **📗** 모범답안

나의 경우 가로배열을 탐색하며 크레인을 동작했는데 모범답안은 세로배열을 탐색한다.

```jsx
const 세로배열변환기 = (가로배열모음) => {
  const 세로배열모음 = 가로배열모음.reduce((누적값, 가로배열) => {
    const 세로배열 = 가로배열.map((_, i) => {
      return [...(누적값[i] || []), 가로배열[i]];
    });
    return 세로배열;
  }, []);

  return 세로배열모음;
};

const solution = (board, moves) => {
  const stacks = 세로배열변환기(board).map((row) =>
    row.reverse().filter((el) => el !== 0)
  );
  const basket = [];
  let result = 0;

  for (const move of moves) {
    const pick = stacks[move - 1].pop();
    if (!pick) continue;
    if (pick === basket[basket.length - 1]) {
      basket.pop();
      result += 2;
      continue;
    }
    basket.push(pick);
  }

  return result;
};
```

## ❓️ **가로배열에서 세로배열로 바꾸는 이유?**

**가로배열을 탐색**
[ 0, 0, 0, 0, 0 ],
[ 0, 0, 1, 0, 3 ],
[ 0, 2, 5, 0, 1 ],
[ 4, 2, 4, 4, 2 ],
[ 3, 5, 1, 3, 1 ]

크레인은 세로순번를 선택한다.
크레인이 1번을 뽑을 경우 첫배열부터 배열마다 배열의 첫원소를 탐색해야하는데
첫번째 배열부터 첫원소로 인형(0이 아닌 원소)이 있는 배열까지 찾아야한다.
이것은 인형까지의 공백(0인 원소)이 많으면 많을수록 탐색 시간이 늘어난다.

**세로배열을 탐색**
[ 0, 0, 0, 4, 3 ],
[ 0, 0, 2, 2, 5 ],
[ 0, 1, 5, 4, 1 ],
[ 0, 0, 0, 4, 3 ],
[ 0, 3, 1, 2, 1 ]

**공백이 제거된 세로 배열**

[ 4, 3 ],
[ 2, 2, 5 ],
[ 1, 5, 4, 1 ],
[ 4, 3 ],
[ 3, 1, 2, 1 ]

가로배열 처럼 크레인이 1번을 뽑을 경우 세로배열은 가로와는 달리 0을 제거할 수 있는데
크레인의 동작(moves)은 세로를 선택하기 때문에 0이 없어도 인형을 뽑을 배열을 선택할 수 있다.
또한 0을 제거 했을때 열마다 0없이 인형만 쌓이기에 0을 거치지 않고 가장위의 인형부터 뽑는다.
이로인해 인형까지 공백이 많더라도 인형이 있는 곳만 탐색을 할 수 있다.

**요약하면 세로배열은 0이 많을수록 효율이 올라가는 방식이라고 할 수 있다.**

결론적으로는 배열이 얼마나 클지 모르기에 세로배열을 제작하는 것이 좀 더 정답에 가깝다.

이를 위해서는 기존의 가로배열을 세로배열로 변경을 하고 공백을 제거해서 탐색을 하도록하겠다.

# ⚙️ ****구현

구현은 크게 **세로 변환 과정** 과 **크레인 동작 과정**으로 나누어 진행한다.

### **세로변환 과정**

1. 가로배열모음을 세로배열모음으로 변경하기 위하여 가로배열모음을 reduce로 받습니다.
2. reduce 안에서는 가로배열을 받아 가로배열의 각 원소를 배열화하고 전체를 배열로 감싸 계속해서 누적

| [[0], [0], [0], [0], [0]] |
| --- |
| [[0, 0], [0, 0], [0, 1], [0, 0], [0, 3]] |
| [[0, 0, 0], [0, 0, 2], [0, 1, 5], [0, 0, 0], [0, 3, 1]] |
| [[0, 0, 0, 4], [0, 0, 2, 2], [0, 1, 5, 4], [0, 0, 0, 4], [0, 3, 1, 2]] |
| [[0, 0, 0, 4, 3],[0, 0, 2, 2, 5],[0, 1, 5, 4, 1],[0, 0, 0, 4, 3],[0, 3, 1, 2, 1]] |

**배열화과정**

```jsx
const 세로배열모음 = 가로배열모음.reduce((누적값, 가로배열) => {
    const 세로배열누적모음 = 가로배열.map((_, i) => {
      return [...(누적값[i] || []), 가로배열[i]];
    });
    return 세로배열누적모음;
}, []);
```

가로배열만큼 세로칸이 존재하기 때문에 가로배열을 map으로 순회하며 배열을 저장합니다.

`const 세로배열 = 가로배열.map((_, i) => {[]}`

map은 배열내의 원소를 변환시키는데 이때 각원소를 배열화하면 세로배열이 생긴다.

`ex) [0, 0, 0, 0, 0] ⇒ [ [0], [0], [0], [0], [0] ]`

map으로 배열을 순회할때 index를 받아 누적값의 i번째 원소가 있다면  해당 원소를 spread로 전개하여 배열에 넣고 현재 가로배열의 index번째 원소를 배열에 넣는 식으로 세로배열마다 값을 누적시킨다.

```jsx
const 세로배열 = 가로배열.map((_, i) => {
    return [...(누적값[i] || []), 가로배열[i]];
});
```

(첫번째 가로배열을 돌릴때는 `누적값[i]`이 undefined이기에 `||` 로 빈배열로 처리해준다.)

`누적값[i] || []`

### **크레인 동작 과정**

1. 세로배열변환기 return값을 `map`으로 배열을 순회하며 각배열을 뒤집고 원소가 0이라면 제거
    
    (배열을 뒤집는 이유는 pop이 shift보다 속도가 빠르기 때문에 pop을 위해 해준다.)
    
2. 이후 크레인의 동작(moves)을 `for of`문으로 돌면서 스택[배열의 각요소 - 1]를 pop하여
    
    스택의 인형을 뽑아 pick에 저장해준다. ( 배열은 0부터 시작하기에 -1 )
    
3. 엣지케이스처리로 뽑을 라인에 인형이 없는 경우 다음 동작으로 넘어간다.
    
    `if (!pick) continue;`
    
4. 그게 아니라면 뽑은인형이 바구니 마지막에 있는 인형과 같다면
    
    바구니 마지막인형을 pop해주고 결과에 2를 더하고 `continue`로 다음 크레인 동작으로 넘긴다.
    
5. 뽑은인형이 바구니 마지막에 있는 인형과 같지않은 경우 `push`로 바구니에 담아준다.
6. 최종적으로 누적된 result를 출력

# 🤔 **배울점**

세로배열을 선택하는 크레인의 특성에 가로배열을 탐색한다는 것은 비효율을 야기할 수 있다는 점은 사실 당장 반복문을 짜서 해결만 하려는 나에게 이 로직이 ***구현에 적절한 방법인가?***를 생각해볼 수 있는 좋은 기회였다.

아무래도 문제마다 해결할 수 있는 방법은 다양하고 완벽한 자료구조나 풀이법은 없을 수 있다.

다만 케이스에 따른 적절한 방법과 저 방법이 아닌 이 방법을 써야하는 이유를 생각한다면 좀 더 답에 가까운 해결법이라고 생각한다.

따라서 기능을 구현하기 앞서 의사코드나 구현을 기획함에 있어서 **구현하려는 기능의 특징을 파악하고 이에 합당한 기능을 구현**할 수 있도록 노력하도록 하자.