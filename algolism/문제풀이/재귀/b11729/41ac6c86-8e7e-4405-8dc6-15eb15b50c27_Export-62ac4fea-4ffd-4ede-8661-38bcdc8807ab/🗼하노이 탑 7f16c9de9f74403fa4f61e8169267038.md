# 🗼하노이 탑

## 문제

---

![sdds.JPG](%F0%9F%97%BC%E1%84%92%E1%85%A1%E1%84%82%E1%85%A9%E1%84%8B%E1%85%B5%20%E1%84%90%E1%85%A1%E1%86%B8%207f16c9de9f74403fa4f61e8169267038/sdds.jpg)

- 한번에 원판 하나만 옮길 수 있다.
- 크기가 작은원판위에 작은 원판이 올 수 없다.
- 최소한의 이동횟수로 form에서 to로 모든원판을 옮겨야 한다.

## 해결방안

---

### **하노이의 탑은 크게 3가지 방식을 재귀적으로 반복하여 해결할 수 있다.**

1. 맨 밑의 원반을 제외한 원반을 other로 옮긴다. (재귀 함수로)
2. 맨밑의 원반을 to(목표)로 옮긴다.
3. other의 원반을 to(목표)로 옮긴다. (재귀 함수로)

![scj.JPG](%F0%9F%97%BC%E1%84%92%E1%85%A1%E1%84%82%E1%85%A9%E1%84%8B%E1%85%B5%20%E1%84%90%E1%85%A1%E1%86%B8%207f16c9de9f74403fa4f61e8169267038/scj.jpg)

## 문제 분해하기

---

위의 방법만 보았을때 “뭐지?” 라고 생각할 수 있지만 문제를 계속해서 작게 생각해 보면 이해할 수 있다.  따라서 위의 과정을 하나씩 이행해 보자.

### 1️⃣ **1번에서 해야할 일은 맨 밑의 원반을 제외한 원반을 other로 옮기는 것 이다.**

(이때는 주황색 원판은 생각할 필요가없기 때문에 생략하겠다.)

![sddsdc.JPG](%F0%9F%97%BC%E1%84%92%E1%85%A1%E1%84%82%E1%85%A9%E1%84%8B%E1%85%B5%20%E1%84%90%E1%85%A1%E1%86%B8%207f16c9de9f74403fa4f61e8169267038/sddsdc.jpg)

### 2️⃣ **하지만 위와같은 결과가 되려면 다시 처음의 3가지 방식을 사용하여야 한다.**

(방식은 똑같지만 2개의 원판의 목표는 2번째 기둥인점을 유의하자)

1. 맨 밑의 원반을 제외한 원반을 other로 옮긴다.
2. 맨밑의 원반을 to(목표)로 옮긴다.
3. other의 원반을 to(목표)로 옮긴다.

![csdfg.JPG](%F0%9F%97%BC%E1%84%92%E1%85%A1%E1%84%82%E1%85%A9%E1%84%8B%E1%85%B5%20%E1%84%90%E1%85%A1%E1%86%B8%207f16c9de9f74403fa4f61e8169267038/csdfg.jpg)

### 3️⃣ 다시 2️⃣의 1번을 실행하려면 처음의 3가지 방식을 이용한다.

(먼저 노란원판은 그대로 이기때문에 생략하고 2번과 달리 목표가 3번째 기둥임을 생각하자.)

1. 맨 밑의 원반을 제외한 원반을 other로 옮긴다.
2. 맨밑의 원반을 to(목표)로 옮긴다.
3. other의 원반을 to(목표)로 옮긴다.

첫번째를 실행하고 싶지만 이제는 맨밑의 원반이 없으므로 더이상 재귀하지 않는다. (base case)

두번째인 맨밑의 원반은 목표로 옮길 수 있다.

세번째는 첫번째 처럼 other의 원반이 없기때문에 재귀하지 않는다. (base case)

![cdfvbsgb.JPG](%F0%9F%97%BC%E1%84%92%E1%85%A1%E1%84%82%E1%85%A9%E1%84%8B%E1%85%B5%20%E1%84%90%E1%85%A1%E1%86%B8%207f16c9de9f74403fa4f61e8169267038/cdfvbsgb.jpg)

> **야호! 이제 더이상 콜스택에 쌓일 재귀함수가 없이 리턴할 수 있겠구나!**
> 

### 4️⃣ 이제 2️⃣의 2번을 실행해보자.

![sdsdc.JPG](%F0%9F%97%BC%E1%84%92%E1%85%A1%E1%84%82%E1%85%A9%E1%84%8B%E1%85%B5%20%E1%84%90%E1%85%A1%E1%86%B8%207f16c9de9f74403fa4f61e8169267038/sdsdc.jpg)

오케이 좋구요..

### 5️⃣ 이제 2️⃣의 3번을 실행하려고 하는데…

3번의 경우 재귀함수로 옮겨야되기 때문에 3️⃣처럼 또 진행해 준다.

(3번을 진행할때는 to와함께 from이 달라지는 걸 생각해야한다.)

1. 맨 밑의 원반을 제외한 원반을 other로 옮긴다. ⇒ 더이상 원판없음
2. 맨밑의 원반을 to(목표)로 옮긴다.
3. other의 원반을 to(목표)로 옮긴다. ⇒ 더이상 원판없음 ⇒ 리턴

![awewqd.JPG](%F0%9F%97%BC%E1%84%92%E1%85%A1%E1%84%82%E1%85%A9%E1%84%8B%E1%85%B5%20%E1%84%90%E1%85%A1%E1%86%B8%207f16c9de9f74403fa4f61e8169267038/awewqd.jpg)

> **이젠 원래의 방식으로 돌아갈 시간이야.. (처음에 호출했던 함수의 2번째로 돌아간다)**
> 

### 6️⃣ 이제는 가장 밑의 원판을 옮길 차례야!

이제 원래의 방식에서 2번째를 진행할 차례이다. 이미 위에서 맨 밑의 원반을 제외한 원반을 other로 옮겼기 때문에 맨밑의 원반을 목표에 쉽게 옮길 수 있다.

![asddwc.JPG](%F0%9F%97%BC%E1%84%92%E1%85%A1%E1%84%82%E1%85%A9%E1%84%8B%E1%85%B5%20%E1%84%90%E1%85%A1%E1%86%B8%207f16c9de9f74403fa4f61e8169267038/asddwc.jpg)

### 7️⃣ 3번째인 other의 원반을 to로 옮기기 위해 다시 3가지를 반복 해야한다..

하지만 걱정마라 위에서 3번째를 진행했던것처럼 다시 진행하면 된다. (똑같은 과정이므로 생략)

![asdwv.JPG](%F0%9F%97%BC%E1%84%92%E1%85%A1%E1%84%82%E1%85%A9%E1%84%8B%E1%85%B5%20%E1%84%90%E1%85%A1%E1%86%B8%207f16c9de9f74403fa4f61e8169267038/asdwv.jpg)

**기억해야 할점은**

- 3가지의 방식을 활용해서 원판을 옮길 것
- 1번 3번케이스에서는 원판이 한개 이상일 경우 다시 3가지 방식을 활용해 옮길 것
- 원판을 옮길때마다 from other to를 잘 구별해서 옮길 것

## 코드작성

---

이제는 위의 내용을 코드로 작성할때가 온것같다.

(문제에 따라 actions나 count를 사용할 수 있다.)

```jsx
const filePath = process.platform === "linux" ? "/dev/stdin" : "./input.txt";
let input = require("fs").readFileSync(filePath, "utf8").trim().split("\n");

let N = Number(input); // 원판의 갯수
let actions = [];
let count = 0;

function Hanoi(num, from, other, to) {
  if (num === 0) {
		// 더이상 옮길 원판 없을때 리턴 (base case)
    return;
  } else {
    // 1. 맨 밑의 원반을 제외한 원반을 other로 옮긴다.
    Hanoi(num - 1, from, to, other);
    // 2. 맨밑의 원반을 to(목표)로 옮긴다. + answer에 행동 기록
    actions.push([from, to]);
		// 총 옮긴 횟수 기록
		count++
    // 3. other의 원반을 to(목표)로 옮긴다.
    Hanoi(num - 1, other, from, to);
  }
}

Hnoi(N, "1", "2", "3");
const answer = [count, ...actions.map((arr) => arr.join(" "))];
console.log(answer.join("\n"));
```

## 코드분석

---

Hnoi 함수에 파라미터로 받는 전달인자는

num=원판수 from=시작위치 other=나머지기둥 to=목표기둥이다.

```jsx
function Hnoi(num, from, other, to) {

}
```

먼저 재귀함수를 멈춰줄 base case를 원판이 없을때 즉, `num === 0` 일때 리턴해준다.

```jsx
if (num === 0) {
    return;
}
```

다음으로 1번인 맨 밑의 원반을 제외한 원반을 other로 옮긴다.인데

현재 원판보다 한개적은 단계에서 other을 목표기둥으로 to를 나머지기둥으로 설정해준다.

```jsx
Hnoi(num - 1, from, to, other);
```

이후 재귀가 base케이스에 도착하여 전체가 리턴 되어 처음에 호출한 Hnoi함수의 다음 코드가 실행된다. 이때 2번인 맨밑의 원반을 to(목표)로 옮긴다.

이 행동을 저장해 줄 수 있고 count를 올려서 총 옮긴횟수를 기록할 수 있다.

```jsx
actions.push([from, to]);
count++;
```

마지막으로 3번 other의 원반을 to(목표)로 옮기면 되는데 이때도 1번과 같이 재귀함수를 실행한다. 다만 도착지점인 to는 그대로이나 나머지 기둥이 from이고 시작지점이 other이다.

```jsx
Hnoi(num - 1, other, from, to);
```

모든 함수가 끝나면 actions와 count에 모든행동과 옮긴횟수가 저장된 것을 출력 양식에 맞게 정제하여 출력해줄 수 있다.

```jsx
Hnoi(N, "1", "2", "3");
const answer = [count, ...actions.map((arr) => arr.join(" "))];
console.log(answer.join("\n"));
```

## 배운점

---

복잡한 문제는 잘게 쪼개서 분해해서 생각을 할 수 있도록 하자. 그리고 재귀함수의 경우에는 정 생각이 안나면 직접 적거나 그리면서 실행해보고 규칙을 찾아서 코드로 변환하도록하자.

처음에는 막막하긴했는데 차근차근 정리하다보니까 이해가 된다. 이처럼 큰 벽에 부딛치더라도 하나씩 생각해서 해결 해보도록 하자