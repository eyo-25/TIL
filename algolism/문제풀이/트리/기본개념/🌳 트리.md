# 🌳 트리

## \***\*Tree\*\*** 개념

---

자료구조 Tree는 이름 그대로 나무의 형태를 가지고 있습니다. 정확히는 나무를 거꾸로 뒤집어 놓은 듯한 모습을 가지고 있습니다. 그래프의 여러 구조 중 **단방향 그래프**의 한 구조로, **하나의 뿌리로부터 가지가 사방으로 뻗은 형태**가 나무와 닮았다고 해서 트리 구조라고 부릅니다.

![183904864-c52bb715-18d0-4768-a05b-ebd5b165c366.png](%F0%9F%8C%B3%20%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5%20d47c2bd2e9684629a2b472d72d9d00ac/183904864-c52bb715-18d0-4768-a05b-ebd5b165c366.png)

마치 가계도와 흡사해 보이는 이 트리 구조는 데이터가 바로 아래에 있는 하나 이상의 데이터에 한 개의 경로와 하나의 방향으로만 연결된 **계층적 자료구조**입니다. 데이터를 순차적으로 나열시킨 선형 구조가 아니라, 하나의 데이터 아래에 여러 개의 데이터가 존재할 수 있는 **비선형 구조**입니다.

트리 구조는 계층적으로 표현이 되고, 아래로만 뻗어나가기 때문에 사이클(cycle)이 없습니다. 여기서 사이클이란 시작 노드에서 출발해 다른 노드를 거쳐 시작 노드로 돌아올 수 있다면 **사이클이 존재한다**고 표현합니다. 따라서 트리는 사이클(cycle)이 없는 하나의 연결 그래프 (Connected Graph)라고 할 수 있습니다.

## \***\*Tree의 구조와 특징\*\***

---

![183905527-63a92add-9606-4e62-ad98-4afdba60dd5b.png](%F0%9F%8C%B3%20%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5%20d47c2bd2e9684629a2b472d72d9d00ac/183905527-63a92add-9606-4e62-ad98-4afdba60dd5b.png)

트리 구조는 **루트(Root)**라는 하나의 꼭짓점 데이터를 시작으로 여러 개의 데이터를 **간선(edge)**으로 연결합니다. 각 데이터를 **노드(Node)**라고 하며, 두 개의 노드가 상하 계층으로 연결되면 부모/자식 관계를 맺습니다. 위 그림에서 A는 B와 C의 부모 노드(Parent Node)이고, B와 C는 A의 자식 노드(Child Node)입니다. 자식이 없는 노드는 나무의 잎과 같다고 하여 리프 노드(Leaf Node)라고 부릅니다.

![183905662-6299a19e-766c-4611-b125-64745f80dcf9.png](%F0%9F%8C%B3%20%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5%20d47c2bd2e9684629a2b472d72d9d00ac/183905662-6299a19e-766c-4611-b125-64745f80dcf9.png)

[그림] 트리 구조의 레벨과 서브 트리

자료구조 Tree는 깊이와 높이, 레벨 등을 측정할 수 있습니다.

### **깊이 (depth)**

트리 구조에서는 **루트로부터 하위 계층의 특정 노드까지의 깊이(depth)**를 표현할 수 있습니다. 루트 노드는 지면에 있는 것처럼 깊이가 0입니다. 위 그림에서 루트 A의 깊이는 0이고, B와 C의 깊이는 1입니다. D, E, F, G의 깊이는 2입니다.

### **레벨(Level)**

트리 구조에서 **같은 깊이를 가지고 있는 노드를 묶어서 레벨(level)**로 표현할 수 있습니다. 깊이가 0인 루트 A의 level은 1입니다. 깊이가 1인 B와 C의 level은 2입니다. D, E, F, G의 레벨은 3입니다. **같은 레벨에 나란히 있는 노드를 형제 노드(Sibling Node)**라고 합니다.

### **높이(Height)**

트리 구조에서 **리프 노드를 기준으로 루트까지의 높이(height)**를 표현할 수 있습니다. 리프 노드와 직간접적으로 연결된 노드의 높이를 표현하며, 부모 노드는 자식 노드의 가장 높은 높이 값에 +1한 값을 높이로 가집니다. 트리 구조의 높이를 표현할 때는 각 리프 노드의 높이를 0으로 놓습니다. 위 그림에서 H, I, E, F, J의 높이는 0입니다. D와 G의 높이는 1입니다. B와 C의 높이는 2입니다. 이때 B는 `D의 height + 1`을, C는 `G의 height + 1`을 높이로 가집니다. 따라서, 루트 A의 높이는 3입니다.

### **서브 트리(Sub tree)**

트리 구조의 루트에서 뻗어 나오는 큰 트리의 내부에, **트리 구조를 갖춘 작은 트리를 서브 트리**라고 부릅니다. (D, H, I)로 이루어진 작은 트리도 서브 트리이고, (B, D, E)나 (C, F, G, J)도 서브 트리입니다.

> 자료구조는 자료의 집합을 구조화하고, 이를 표현하는 데에 초점이 맞춰져 있습니다. 여러분은 이미 자료구조를 알게 모르게 많이 접했습니다. 사람이 자료를 사용하기에 편리하도록 만들어진 것이 자료구조이기 때문입니다.

### **용어정리**

- 노드(Node) : 트리 구조를 이루는 모든 개별 데이터
- 루트(Root) : 트리 구조의 시작점이 되는 노드
- 부모 노드(Parent node) : 두 노드가 상하관계로 연결되어 있을 때 상대적으로 루트에서 가까운 노드
- 자식 노드(Child node) : 두 노드가 상하관계로 연결되어 있을 때 상대적으로 루트에서 먼 노드
- 리프(Leaf) : 트리 구조의 끝 지점이고, 자식 노드가 없는 노드

## 실사용 예시

---

- 컴퓨터의 디렉토리 구조
- 월드컵 토너먼트 대진표
- 가계도, 조직도 등

## 구현

---

```jsx
class Tree {
  //tree의 constructor를 구현합니다.
  //tree의 자식 노드들을 children으로 할당하여 노드의 자식 노드들을 담을 수 있게 설정합니다.
  constructor(value) {
    this.value = value;
    this.children = [];
  }
  //tree의 자식 노드를 생성 한 후에, 노드의 children에 push해 줍니다.
  insertNode(value) {
    const childNode = new Tree(value);
    this.children.push(childNode);
  }
  // tree에서 value값을 탐색합니다.
  // 현재 노드의 value 값이 찾는 값과 일치한다면 return합니다.
  contains(value) {
    if (this.value === value) {
      return true;
    }
    // 노드가 가진 자식 노드를 순회하는 반복문으로 노드의 children 배열을 탐색합니다.
    for (let i = 0; i < this.children.length; i += 1) {
      const childNode = this.children[i];
      if (childNode.contains(value)) {
        return true;
      }
    }
    return false;
  }
}
```

## 구현2

---

트리는 노드(Node)로 구성된 비선형 자료구조로, 각 노드는 부모-자식 관계를 가지며 트리의 루트(Root) 노드를 제외한 모든 노드는 단 하나의 부모 노드와 연결됩니다.

```jsx
class Node {
  constructor(data) {
    this.data = data; // 다른 노드와 차별점을 두는 데이터
    this.children = []; // 자식들과의 정보(주소)를 담을 배열
  }

  addChild(data) {
    // 자식 추가하는 메소드
    this.children.push(new Node(data));
    // 자식 노드를 생성하고 바로 배열에 저장한다. (주소를 저장하는 행위)
  }

  removeChild(data) {
    // 자식의 정보를 지우는 메소드
    this.children = this.children.filter((child) =>
      child.data === data ? false : true
    ); // filter 를 거쳐서 해당하는 자식의 정보를 배열에서 빼주면 된다.
  }
}

class Tree {
  constructor() {
    this.root = null;
  }
}
```

먼저 트리를 생성한다.

```jsx
// 빈 트리를 생성 해 주고
const t = new Tree(); //Tree { root: null }
```

루트에 Node를 저장해준다.

```jsx
// 루트가 node 'a'의 주소를 가리키면 'a' 의 자식들까지 접근 가능하다.
t.root = new Node("a"); //Tree { root: Node { data: 'a', children: [] } }
```

```jsx
t.root.addChild("b"); // a의 자식 'b', 'c'
t.root.addChild("c");

//Tree { root: Node { data: 'a', children: [ [Node], [Node] ] } }
```

[인접 행렬, 리스트로 짯을때 차이](https://www.notion.so/c720ac3d125041948f9bc51415603099)
