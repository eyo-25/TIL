# 🗑️ 가비지 컬렉션

[https://developer.mozilla.org/ko/docs/Web/JavaScript/Memory_management](https://developer.mozilla.org/ko/docs/Web/JavaScript/Memory_management)

[https://ko.javascript.info/garbage-collection](https://ko.javascript.info/garbage-collection)
[https://medium.com/sessionstack-blog/how-javascript-works-memory-management-how-to-handle-4-common-memory-leaks-3f28b94cfbec](https://medium.com/sessionstack-blog/how-javascript-works-memory-management-how-to-handle-4-common-memory-leaks-3f28b94cfbec)

[https://www.youtube.com/watch?v=rLx7yfdMgHQ](https://www.youtube.com/watch?v=rLx7yfdMgHQ)

[https://fe-developers.kakaoent.com/2022/220519-garbage-collection/](https://fe-developers.kakaoent.com/2022/220519-garbage-collection/)

[https://koguri.tistory.com/78](https://koguri.tistory.com/78)

[https://eblee-repo.tistory.com/52](https://eblee-repo.tistory.com/52)

[https://ui.toast.com/posts/ko_20210611](https://ui.toast.com/posts/ko_20210611)

![1806838713_azTseVqA_9DB8DE06-7B68-4012-8205-30615C35112D.jpg](%F0%9F%97%91%EF%B8%8F%20%E1%84%80%E1%85%A1%E1%84%87%E1%85%B5%E1%84%8C%E1%85%B5%20%E1%84%8F%E1%85%A5%E1%86%AF%E1%84%85%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%20c5797b9fd2d54fc19a57f9ed5f87c69c/1806838713_azTseVqA_9DB8DE06-7B68-4012-8205-30615C35112D.jpg)

[공부한 내용도 누가 자꾸 가비지 컬렉션하는 것 같다..]

## 개요

---

C 언어같은 저수준 언어에서는 메모리 관리를 위해 malloc() 과 free()를 사용합니다. 반면, 자바스크립트는 객체가 생성되었을 때 자동으로 메모리를 할당하고 더 이상 필요하지 않을 때 자동으로 해제합니다(가비지 컬렉션). 이러한 자동 메모리 관리는 잠재적 혼란의 원인이기도 한데, 개발자가 메모리 관리에 대해 고민할 필요가 없다는 잘못된 인식을 심어줄 수 있기 때문입니다.

## 가비지 컬렉션 개념

---

### 가비지 컬렉션

자바스크립트(JavaScript)에서 가비지 컬렉션(Garbage Collection)은 메모리 관리를 위한 핵심 개념입니다. **가비지 컬렉션은 사용하지 않는 메모리를 자동으로 감지하고 해제하여 프로그램의 메모리 누수를 방지**합니다.

자바스크립트는 가비지 컬렉션을 통해 동적으로 할당된 메모리를 관리합니다. 이는 개발자가 명시적으로 메모리를 할당하거나 해제하지 않아도 되는 이점을 제공합니다. 대신, 자바스크립트 엔진은 가비지 컬렉션 알고리즘을 사용하여 더 이상 필요하지 않은 메모리를 식별하고 자동으로 해제합니다.

### 가비지

**가비지는 더 이상 사용되어지지 않지 메모리이고 아직 방출되지 않은 메모리를 의미**합니다.

여기서 사용되지 않는 메모리와 방출되지 않는 메모리는 아래의 메모리 라이프 사이클과 함께 설명드리겠습니다.

## 메모리의 라이프 사이클

---

![1_slxXgq_TO38TgtoKpWa_jQ.webp](%F0%9F%97%91%EF%B8%8F%20%E1%84%80%E1%85%A1%E1%84%87%E1%85%B5%E1%84%8C%E1%85%B5%20%E1%84%8F%E1%85%A5%E1%86%AF%E1%84%85%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%20c5797b9fd2d54fc19a57f9ed5f87c69c/1_slxXgq_TO38TgtoKpWa_jQ.webp)

메모리는 Alloacte memory (메모리 할당) > Use memory (메모리 사용) > Release memory (메모리 방출) 순으로 진행됩니다.

### 1. **Alloacte memory 할당**

자바스크립트는 변수를 선언할 때 자동으로 메모리를 할당합니다. 원시 타입의 값들은 스택 영역에 저장되고, 참조 타입의 값은 힙 영역에 저장되며, 그 주소값은 스택 영역에 저장됩니다. 또한 변수 식별자는 스택 영역 상의 실행 컨텍스트의 렉시컬 환경에 저장됩니다.

![memory.png](%F0%9F%97%91%EF%B8%8F%20%E1%84%80%E1%85%A1%E1%84%87%E1%85%B5%E1%84%8C%E1%85%B5%20%E1%84%8F%E1%85%A5%E1%86%AF%E1%84%85%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%20c5797b9fd2d54fc19a57f9ed5f87c69c/memory.png)

```jsx
var n = 123; // 정수를 담기 위한 메모리 할당
var s = 'azerty'; // 문자열을 담기 위한 메모리 할당

var o = {
  a: 1,
  b: null
}; // 오브젝트와 그 오브젝트에 포함된 값들을 담기 위한 메모리 할당

// (오브젝트처럼) 배열과 배열에 담긴 값들을 위한 메모리 할당
var a = [1, null, 'abra'];

function f(a) {
  return a + 2;
} // 함수를 위한 할당(함수는 호출 가능한 오브젝트)

// 함수식 또한 오브젝트를 담기 위한 메모리를 할당합니다.
someElement.addEventListener(
  "click",
  () => {
    someElement.style.backgroundColor = "blue";
  },
  false,
);
```

![1_5aBou4onl1B8xlgwoGTDOg.webp](%F0%9F%97%91%EF%B8%8F%20%E1%84%80%E1%85%A1%E1%84%87%E1%85%B5%E1%84%8C%E1%85%B5%20%E1%84%8F%E1%85%A5%E1%86%AF%E1%84%85%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%20c5797b9fd2d54fc19a57f9ed5f87c69c/1_5aBou4onl1B8xlgwoGTDOg.webp)

### 2. Use memory 사용(참조)

전역 실행 컨텍스트 렉시컬 환경에 있는 식별자 a, b를 참조합니다.

```jsx
console.log(number); // 변수에 저장된 값 사용
console.log(name); // 변수에 저장된 값 사용

console.log(person.name); // 객체 속성 값 사용
console.log(person.age); // 객체 속성 값 사용
```

### 3. Release memory 해제

**할당된 메모리가 더 이상 필요없을 때 해제하기**

사용하지 않는 메모리는 가비지 컬렉션(Garbage Collection)에 의해 해제됩니다. 가비지 컬렉션은 자동으로 더 이상 참조되지 않는 메모리를 감지하고, 해당 메모리를 **자동으로 해제**하여 다시 사용 가능한 상태로 만듭니다. 

![asddasd.png](%F0%9F%97%91%EF%B8%8F%20%E1%84%80%E1%85%A1%E1%84%87%E1%85%B5%E1%84%8C%E1%85%B5%20%E1%84%8F%E1%85%A5%E1%86%AF%E1%84%85%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%20c5797b9fd2d54fc19a57f9ed5f87c69c/asddasd.png)

이러한 메모리 라이프 사이클은 자바스크립트의 메모리 관리를 단순화하고, 개발자가 메모리 할당과 해제에 대한 직접적인 관리를 신경쓰지 않아도 되는 이점을 제공합니다. 자바스크립트 엔진은 가비지 컬렉션을 통해 사용되지 않는 메모리를 자동으로 해제하여 메모리 누수를 방지하고, 메모리 관리 부담을 최소화합니다.

그렇다면 GC는 어떤 기준으로 메모리 영역을 더 이상 쓸모없다고 판단할까요? 또 어떠한 원리로 가비지 컬렉션이 동작할까요?

## 가비지 컬렉션 기준

---

자바스크립트는 메모리 관리를 수행할 때 **도달 가능성(reachability)** 이라는 개념을 사용합니다. 도달 가능한 값은 메모리에서 절대 삭제되지 않습니다.

### **도달 가능성(reachability)**

- 어떻게든 접근하거나 사용할 수 있는 값
- 도달 가능한 값은 메모리에서 삭제 되지 않음

### **도달 가능한 값**

1. **태생부터 도달 가능한 값 = `root` 라고 부름**
    - 전역 변수 등
    - 현재 함수의 지역 변수와 매개변수
    - 중첩 함수의 체인에 있는 함수에서 사용 되는 변수와 매개변수
2. **`root`가 참조하는 값이나 체이닝으로 루트에서 참조할 수 있는 값**
    - 예를 들어 전역 변수에 객체가 저장되어 있다고 가정했을 때, 이 객체의 프로퍼티가 또 다른 객체를 참조하고 있다면 프로퍼티가 참조하는 객체는 도달 가능한 값이 됩니다.

## 가비지 컬렉터 예시

---

### ****예시1 - 간단한 예시****

```jsx
// user엔 객체 참조 값이 저장됩니다.
let user = {
    name: "John"
};
```

![1.png](%F0%9F%97%91%EF%B8%8F%20%E1%84%80%E1%85%A1%E1%84%87%E1%85%B5%E1%84%8C%E1%85%B5%20%E1%84%8F%E1%85%A5%E1%86%AF%E1%84%85%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%20c5797b9fd2d54fc19a57f9ed5f87c69c/1.png)

- 왼쪽의 그림에서 화살표는 객체 참조를 나타냅니다.
- 그림을 해석하면, 전역 변수 **`user`** 는 **`{name:”John”}`** 이라는 객체를 참조하고 있습니다.
- John의 프로퍼티인 **`name`** 은 원시값을 저장하고 있기 때문에 객체 안에 표현합니다.

만약 이 상태에서 user의 값을 다른 값으로 덮어쓰면 참조(화살표)가 사라지게 됩니다.

```jsx
user = null;
```

![2.png](%F0%9F%97%91%EF%B8%8F%20%E1%84%80%E1%85%A1%E1%84%87%E1%85%B5%E1%84%8C%E1%85%B5%20%E1%84%8F%E1%85%A5%E1%86%AF%E1%84%85%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%20c5797b9fd2d54fc19a57f9ed5f87c69c/2.png)

- 왼쪽의 그림과 같이 이제 John은 도달할 수 없는 상태가 됩니다.
- John에 접근할 방법도, John을 참조하는 것도 모두 사라집니다.

### ****예시2 - 참조가 두개****

```jsx
// user엔 객체 참조 값이 저장
let user = {
    name: "John"
};

let admin = user;
```

![3.png](%F0%9F%97%91%EF%B8%8F%20%E1%84%80%E1%85%A1%E1%84%87%E1%85%B5%E1%84%8C%E1%85%B5%20%E1%84%8F%E1%85%A5%E1%86%AF%E1%84%85%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%20c5797b9fd2d54fc19a57f9ed5f87c69c/3.png)

그리고 위에서 한것 처럼 `user`의 값을 다른 값으로 덮어써 봅시다.

```jsx
user = null;
```

- 위 코드처럼 user를 null값으로 덮어쓰더라도, 전역 변수 admin을 통하면 여전히 객체 John에 접근할 수 있기 때문에 John은 메모리에서 삭제되지 않습니다.
- 다만 **`admin`**도 다른 값(null 등)으로 덮어쓰게 된다면 John은 메모리에서 삭제 될 수 있습니다.

### ****예시3 - 연결된 객체****

```jsx
function marry(man, woman) {
  woman.husband = man;
  man.wife = woman;

  return {
    father: man,
    mother: woman
  }
}

let family = marry({
  name: "John"
}, {
  name: "Ann"
});

// family =
// {father: {name: "John", wife: "Ann"}, mother: {name: "Ann", husband: "John"}}
```

함수 `marry`(결혼하다)는 매개변수로 받은 두 객체를 서로 참조하게 하면서 '결혼’시키고, 두 객체를 포함하는 새로운 객체를 반환합니다.

메모리 구조는 아래와 같이 나타낼 수 있습니다.

![4.png](%F0%9F%97%91%EF%B8%8F%20%E1%84%80%E1%85%A1%E1%84%87%E1%85%B5%E1%84%8C%E1%85%B5%20%E1%84%8F%E1%85%A5%E1%86%AF%E1%84%85%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%20c5797b9fd2d54fc19a57f9ed5f87c69c/4.png)

지금은 모든 객체가 도달 가능한 상태입니다.

이제 참조 두 개를 지워보겠습니다.

```jsx
delete family.father;
delete family.mother.husband;

// family =
// {mother: {name: "Ann"}
```

![5.png](%F0%9F%97%91%EF%B8%8F%20%E1%84%80%E1%85%A1%E1%84%87%E1%85%B5%E1%84%8C%E1%85%B5%20%E1%84%8F%E1%85%A5%E1%86%AF%E1%84%85%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%20c5797b9fd2d54fc19a57f9ed5f87c69c/5.png)

- 참조 두 개를 지움으로써 John으로 들어오는 참조(화살표)가 모두 사라집니다.
- 즉, John은 도달 가능한 상태에서 벗어납니다.

![6.png](%F0%9F%97%91%EF%B8%8F%20%E1%84%80%E1%85%A1%E1%84%87%E1%85%B5%E1%84%8C%E1%85%B5%20%E1%84%8F%E1%85%A5%E1%86%AF%E1%84%85%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%20c5797b9fd2d54fc19a57f9ed5f87c69c/6.png)

- 즉, John은 도달 가능한 상태에서 벗어납니다.
- 외부로 나가는 참조는 도달 가능한 상태에 영향을 주지 않습니다.
- 이제 John은 도달 가능한 상태가 아니기 때문에 메모리에서 제거되며, John에 저장된 데이터(프로퍼티) 역시 메모리에서 사라집니다.

![7.png](%F0%9F%97%91%EF%B8%8F%20%E1%84%80%E1%85%A1%E1%84%87%E1%85%B5%E1%84%8C%E1%85%B5%20%E1%84%8F%E1%85%A5%E1%86%AF%E1%84%85%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%20c5797b9fd2d54fc19a57f9ed5f87c69c/7.png)

- 가비지 컬렉션 후 최종 메모리 구조는 위와 같습니다.

> 사실 Reference-counting 알고리즘에 따르면, 함수 내에서 두 객체가 서로를 참조하는 **순환 참조**는 객체가 여전히 서로를 참조하고 있기 때문에 가비지 컬렉팅되지 않습니다.(= **메모리 누수 발생!**) 하지만 이는 Mark-and-Sweep 알고리즘에 의해 보완됩니다.
> 

### ****예시4 - 도달할 수 없는 섬****

객체들이 연결되어 섬 같은 구조를 만드는데, 이 섬에 도달할 방법이 없는 경우, 섬을 구성하는 객체 전부가 메모리에서 삭제됩니다.

근원 객체 `family`가 아무것도 참조하지 않도록 해 봅시다.

```jsx
family = null;
```

![8.png](%F0%9F%97%91%EF%B8%8F%20%E1%84%80%E1%85%A1%E1%84%87%E1%85%B5%E1%84%8C%E1%85%B5%20%E1%84%8F%E1%85%A5%E1%86%AF%E1%84%85%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%20c5797b9fd2d54fc19a57f9ed5f87c69c/8.png)

- John과 Ann은 여전히 서로를 참조하고 있지만, 근원 객체(root)가 참조하고 있지 않습니다.
- 따라서 섬을 구성하는 객체 전부가 메모리에서 제거됩니다.

## ****가비지 컬렉션 알고리즘****

---

가비지 컬렉션은 크게 두 가지 알고리즘이 존재합니다

## 1️⃣ **Reference-Counting**

---

말 그대로 참조 개수를 카운팅하면서, 참조가 하나도 없으면 가비지로 판단하는 방식입니다. 결국 위에서 설명한 예시들의 동작과정을 의미합니다.

## 2️⃣ **Mark-and-Sweep**

---

Mark-and-sweep는 자바스크립트에서 가장 일반적으로 사용되는 가비지 컬렉션(GarbageCollection) 알고리즘 중 하나입니다. 이 알고리즘은 더 이상 사용되지 않는 메모리를 식별하고 해제하는 데 사용됩니다.

이 알고리즘에서는 "더 이상 필요 없는 객체"를 "닿을 수 없는 객체"로 정의합니다. 이름에서 알 수 있듯이 무엇인 가에 표시(Mark)를 하고, 정리하는(Sweep) 알고리즘입니다.

### 1. 마크(Mark) 단계:

- 가비지 컬렉션은 루트(root)로부터 시작하여 도달 가능한 모든 객체를 식별하기 위해 객체 그래프를 순회합니다.
- 루트는 일반적으로 전역 객체(window) 및 실행 중인 함수의 지역 변수와 매개변수 등을 포함합니다.
- 순회 중, 가비지 컬렉션은 방문한 객체를 마킹(Marking)하여 도달 가능한 객체로 표시합니다. 일반적으로 마킹은 객체 내부에 특별한 플래그를 설정하거나 비트맵을 사용하여 수행됩니다.

[마크(mark) 단계 도식화](https://www.notion.so/mark-92acf0e200294a01aeb7dde654c97a49)

### 2. 스윕(Sweep) 단계:

- 마크 단계 이후, 가비지 컬렉션은 힙(Heap)의 모든 객체를 순회하며 마킹되지 않은 객체를 식별합니다.
- 마킹되지 않은 객체는 도달할 수 없는 객체로 간주되고, 이러한 객체는 더 이상 필요하지 않으므로 메모리에서 해제됩니다.
- 메모리 해제는 객체를 삭제하고 해당 메모리 공간을 재사용 가능한 상태로 만드는 작업을 의미합니다.

방문할 수 없었던 객체를 메모리에서 삭제합니다.

![ascsscx.JPG](%F0%9F%97%91%EF%B8%8F%20%E1%84%80%E1%85%A1%E1%84%87%E1%85%B5%E1%84%8C%E1%85%B5%20%E1%84%8F%E1%85%A5%E1%86%AF%E1%84%85%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%20c5797b9fd2d54fc19a57f9ed5f87c69c/ascsscx.jpg)

### 단점 : **가비지 컬렉션의 일시 중지**

- Mark-and-sweep 알고리즘은 일시 중지(Suspension)를 수행하여 애플리케이션의 실행을 일시적으로 멈춥니다.
- 중지 시간 동안 가비지 컬렉션은 객체 그래프를 분석하고 메모리 해제 작업을 수행합니다.
- 일시 중지 시간은 매우 짧아서 대부분의 경우 사용자에게는 불편을 주지 않습니다. 하지만 매우 큰 객체 그래프나 메모리 사용량이 많은 경우에는 가시적인 중지가 발생할 수 있습니다.

해당 과정에서 전체 스레드가 멈춥니다. **stop-the-world**라고 불리기도 하며 흔히 가비지 컬렉션에서 성능 저하를 언급하는 것도 이 때문입니다.

### 쉽게 생각하기

루트에서 페인트를 들이붓는다고 상상하면 이 과정을 이해하기 쉽습니다. 루트를 시작으로 참조를 따라가면서 도달가능한 객체 모두에 페인트가 칠해진다고 생각하면 됩니다. 이때 페인트가 묻지 않은 객체는 메모리에서 삭제됩니다.

개념을 통해 실제 적용을 하고 싶었지만 분량 조절 실패로 다음엔 위와같은 내용을 바탕으로 메모리 누수를 정리해 보겠습니다.

메모리 누수 참고링크

[https://yceffort.kr/2020/07/memory-leaks-in-javascript](https://yceffort.kr/2020/07/memory-leaks-in-javascript)