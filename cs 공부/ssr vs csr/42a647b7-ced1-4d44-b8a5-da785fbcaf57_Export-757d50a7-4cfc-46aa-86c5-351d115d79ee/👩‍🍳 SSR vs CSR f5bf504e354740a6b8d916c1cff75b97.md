# 👩‍🍳 SSR vs CSR

[https://hahahoho5915.tistory.com/52#](https://hahahoho5915.tistory.com/52#:~:text=CSR%EC%9D%80%20%EC%9D%B4%EB%AF%B8%20%EC%B2%AB%20%ED%8E%98%EC%9D%B4%EC%A7%80,%EA%B7%B8%EB%9E%98%EC%84%9C%20%EB%8D%94%20%EB%8A%90%EB%A6%AC%EB%8B%A4.&text=%EA%B2%80%EC%83%89%20%EC%97%94%EC%A7%84%EC%9D%80%20%EC%9E%90%EB%8F%99%ED%99%94%EB%90%9C,%EB%A1%9C%20%EC%9B%B9%20%EC%82%AC%EC%9D%B4%ED%8A%B8%EB%93%A4%EC%9D%84%20%EC%9D%BD%EB%8A%94%EB%8B%A4)

# 📺︎ ****SSR(Server Side Rendering)****

![img1.daumcdn.png](%F0%9F%91%A9%E2%80%8D%F0%9F%8D%B3%20SSR%20vs%20CSR%20f5bf504e354740a6b8d916c1cff75b97/img1.daumcdn.png)

## 📘 **SSR 개념**

> **서버에서 웹 페이지를 브라우저로 보내기 전에 서버에서 완전히 렌더링했기 때문에 Server Side Rendering 이라고 합니다.**
> 

브라우저가 서버의 URI로 `GET` 요청을 보내면, 서버는 정해진 웹 페이지 파일을 브라우저로 전송합니다. 그리고 서버의 웹 페이지가 브라우저에 도착하면 완전히 렌더링됩니다.

**웹 페이지의 내용에 데이터베이스의 데이터가 필요한 경우**

서버는 데이터베이스의 데이터를 불러온 다음, 웹 페이지를 완전히 렌더링 된 페이지로 변환한뒤 브라우저에 응답으로 보냅니다.

**페이지를 살펴보던 사용자가, 브라우저의 다른 경로로 이동시**

브라우저가 다른 경로로 이동할 때마다 서버는 같은 작업을 다시 수행합니다.

## 🕹 SSR **작동순서**

![img1.daumcdn.png](%F0%9F%91%A9%E2%80%8D%F0%9F%8D%B3%20SSR%20vs%20CSR%20f5bf504e354740a6b8d916c1cff75b97/img1.daumcdn%201.png)

**위의 사진은 SSR의 단계를 설명한다.**

1. User가 Website 요청을 보낸다.

2. Server는 'Ready to Render'. 즉, 즉시 **렌더링 가능한 html파일을 만든다.**

(리소스 체크, 컴파일 후 완성된 HTML 컨텐츠로 만든다.)

3. 클라이언트에 전달되는 순간, 이미 렌더링 준비가 되어있기 때문에 HTML은 즉시 렌더링 된다.

(**Javascript가 읽히기 전이기때문에 사이트 자체는 조작 불가능하다**)

4. 클라이언트가 자바스크립트를 다운받는다.

5. 다운 받아지고 있는 사이에 유저는 컨텐츠는 볼 수 있지만 사이트를 조작 할 수는 없다.

(이때의 사용자 조작을 기억하고 있는다.)

6. 브라우저가 Javascript 프레임워크를 실행한다.

7. JS까지 성공적으로 컴파일 되었기 때문에 기억하고 있던 사용자 조작이 실행되고 이제 웹 페이지는 상호작용 가능해진다.

> 즉. 서버에서 이미 '렌더 가능한' 상태로 클라이언트에 전달되기 때문에,
> 
> 
> JS가 다운로드 되는 동안 사용자는 무언가를 보고 있을 수 있다.
> 

![HJHJH.JPG](%F0%9F%91%A9%E2%80%8D%F0%9F%8D%B3%20SSR%20vs%20CSR%20f5bf504e354740a6b8d916c1cff75b97/HJHJH.jpg)

# 🪐 C****SR(Client Side Rendering)****

![OfxuhVcgB-1619657798309.png](%F0%9F%91%A9%E2%80%8D%F0%9F%8D%B3%20SSR%20vs%20CSR%20f5bf504e354740a6b8d916c1cff75b97/OfxuhVcgB-1619657798309.png)

## 📘 C**SR 개념**

> CSR은 Client Side Rendering 을 의미합니다. 일반적으로 CSR은 SSR의 반대로 여겨집니다. SSR이 서버 측에서 페이지를 렌더링한다면, CSR은 클라이언트에서 페이지를 렌더링합니다.
> 

웹 개발에서 사용하는 대표적인 클라이언트는 **웹 브라우저**입니다. 브라우저의 요청을 서버로 보내면 서버는 웹 페이지를 렌더링하는 대신, **웹 페이지의 골격이 될 단일 페이지(Single Page)를 클라이언트에 보냅니다.**

이때 서버는 웹 페이지와 함께 JavaScript 파일을 보냅니다. 클라이언트가 웹 페이지를 받으면, 웹 페이지와 함께 전달된 JavaScript 파일은 브라우저의 웹 페이지를 완전히 렌더링 된 페이지로 바꿉니다.

**데이터베이스에 저장된 데이터인 경우**

브라우저는 데이터베이스에 저장된 데이터를 가져와서 웹 페이지에 렌더링을 해야 합니다. 이를 위해 Fetch와 같은 API가 사용됩니다.

**브라우저가 다른 경로로 이동시**

CSR에서는 SSR과 다르게, **서버가 웹 페이지를 다시 보내지 않습니다**. 브라우저는 브라우저가 요청한 경로에 따라 페이지를 다시 렌더링합니다. 이때 보이는 웹 페이지의 파일은 맨 처음 서버로부터 전달받은 웹 페이지 파일과 동일한 파일입니다.

## 🕹 C**SR 작동순서**

![img1.daumcdn.png](%F0%9F%91%A9%E2%80%8D%F0%9F%8D%B3%20SSR%20vs%20CSR%20f5bf504e354740a6b8d916c1cff75b97/img1.daumcdn%202.png)

**위의 사진은 CSR의 단계를 설명한다.**

1. User가 Website요청을 보낸다.

2. CDN이 HTML 파일과 JS로 접근할 수 있는 링크를 클라이언트로 빠르게 보낸다.

3. 클라이언트는 서버로 부터 빈 HTML를다운로드 받는다.

4. 클라이언트는 서버로 부터 연결된 JS링크를 받아 다운로드한다.

**(SSR과 달리 HTML와 JS를 다운받기 전까지 유저는 아무것도 볼 수 없다.)**

5. 다운이 완료된 JS가 실행된다. 데이터를 위한 API가 호출된다.

(이때 유저들은 placeholder를 보게된다. )

6. 서버가 API로부터의 요청에 응답한다.

7. API로부터 받아온 data를 placeholder 자리에 넣어준다. 이제 페이지는 상호작용이 가능해진다.

![SSS.JPG](%F0%9F%91%A9%E2%80%8D%F0%9F%8D%B3%20SSR%20vs%20CSR%20f5bf504e354740a6b8d916c1cff75b97/SSS.jpg)

# ⚔️ SSR과 C****SR의 장단점****

![SDSDSD].JPG](%F0%9F%91%A9%E2%80%8D%F0%9F%8D%B3%20SSR%20vs%20CSR%20f5bf504e354740a6b8d916c1cff75b97/SDSDSD.jpg)

🔵 : CSR 🔴 : SSR

## **웹페이지를 로딩하는 시간**

**첫 페이지 로딩시간**

🔵 CSR의 경우 첫페이지 로딩시 HTML, CSS와 모든 스크립트들을 한 번에 불러온다.

🔴 반면 SSR은 첫페이지에 필요한 HTML과 스크립트만 불러오게 된다.

**▶ 평균적으로 SSR이 더 빠르다.**

**나머지 로딩 시간** (첫 페이지 로딩 후, 사이트의 다른 곳으로 이동한 경우 : 라우팅)

🔵 CSR은 첫 페이지 로딩할 때 나머지 부분을 구성하는 코드를 받아왔기 때문에 **로딩이 빠르다.**

🔴 반면, SSR은 첫 페이지를 로딩한 과정을 정확하게 다시 실행한다. 그래서 더 느리다.

## **SEO 대응**

검색 엔진은 자동화된 로봇인 '크롤러'로 웹 사이트들을 읽어 검색가능한 색인을 만든다.

🔵 CSR은 **빈 HTML**을 가지고 자바스크립트를 실행시켜 동적으로 컨텐츠가 생성되는 형식으로 동작하기 때문에 크롤러 입장에서 색인을 할만한 컨텐츠가 없어 **SEO가 잘 되지 않는다.**

(다만 구글봇은 자바스크립트도 크롤링하고 있다. 다만 대부분은 크롤링이 힘들다)

🔴 SSR은 애초에 서버 사이드에서 컴파일되어 클라이언트로 넘어오기 때문에 크롤러가 많은 정보를 읽어 색인을 만들기 용이하기 때문에  SEO가 잘된다.

## **서버 자원 사용**

🔵 CSR은 클라이언트에서 렌더링을 하기 때문에 서버에 부하가 적다

🔴 **SSR은 매번 서버에서 렌더링을 해야되기 때문에 자원을 더많이 사용한다.**

## UX 경험

🔵 CSR은 화면이 나타나고 나면 인터렉션과 페이지 이동이 자유로워 UX 경험이 긍정적이다.

🔵 TTV === TTI (사용자가 보는 시점과 인터렉션하는 시점이 동일)

🔴 SSR은 초기 화면이 렌더링 되어 보여도 JS가 연결되기 전까지는 인터렉션에 반응이 없고 페이지 이동시 깜빡거리는 현상이 있어 UX적으로 불편하다.

🔴 **TTV !== TTI (사용자가 보는 시점과 인터렉션하는 시점이 동일하지 않음)**

# 🛠️ CSR의 단점 보완 방법

## Universal Rendering

![hjhjhjh.JPG](%F0%9F%91%A9%E2%80%8D%F0%9F%8D%B3%20SSR%20vs%20CSR%20f5bf504e354740a6b8d916c1cff75b97/hjhjhjh.jpg)

# 🔔 어떤 방식의 렌더링을 사용해야할까?

## 서비스의 성격에 따라 도입

**case 1. 대부분이 고객 개인 정보로 이루어진 페이지라 검색 엔진에 노출될 필요가 없고 상호작용이 많은 경우**

⇒ CSR **(동적인 경우 추천)**

**case 2. 회사 홈페이지 처럼 누구에게나 동일한 화면을 보여주고 매주 업데이트 되는 경우**

⇒ SSR **(정적인 경우 추천)**

**case 3. 사용자에 따라 페이지도 달라지고 인터렉션도 되면서 상위 노출되면 좋은 경우**

⇒ UNIVERSAL RENDERING