# 타입을 파라미터로 입력하는 Generic

`function 함수<타입파라미터>(){}` 로 파라미터를 받아와서 함수실행할때 타입전달할 수 있다.

nerrowing하는 것보다 **확장성이 더 뛰어나다** return이나 파라미터의 타입을 바꿀 수 있기때문

```tsx
function 함수<MyType, MyType2>(x: MyType2): MyType {
  return x[0];
}

let a = 함수<number, number[]>([4, 2]);
console.log(a);

let b = 함수<string, string[]>(["a", "b"]);
console.log(b);
```

하지만 아래의 경우 함수의 입장에서는 **mytype으로 뭐가 들어올지 모르기 때문에** return인

x - 1를 할때 x가 string으로 올 수 도있기에 에러를 출력한다.

```tsx
function 함수<MyType>(x : MyType){
	return x - 1 // 에러
}

let a = 함수<number>(100)
```

이럴때는 `타입파라미터 extends 체크할 타입` 으로 타입파라미터를 제한을 두어 사용할 수 있다.

여기에서 `extends` 의 경우 **타입파라미터가 체크할 타입인지 if문으로 체크하는 문법**이다.

(일종의 nerrowing을 대체한다고 볼 수 있다.)

```tsx
function 함수<MyType extends number>(x : MyType){
	return x - 1
}

let a = 함수<number>(100)
```

또한 **커스텀 타입으로 extends**가 가능하다.

```tsx
interface lengthCheck {
  length : number
}
function 함수<MyType extends lengthCheck>(x: MyType) {
  return x.length
}

let a = 함수<string>('hello')  //가능
let a = 함수<number>(1234) //에러남
```

class에 제네릭 사용

```tsx
class Person<MyType> {
  name: MyType;
  constructor(a: MyType) {
    this.name = a;
  }
}

let a = new Person<string>("어쩌구");
const aName = a.name; // aName는 타입 string
console.log(aName);

let b = new Person<string[]>(["어쩌구", "저쩌구"]);
const bName = b.name; // bName는 타입 string[]
console.log(bName);
```